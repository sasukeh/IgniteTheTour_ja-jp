# アプリケーションをより迅速かつ安全に展開する

アプリケーションの展開は長年にわたり大きく変化し、面倒な手動タスクがスクリプト化されたルーチンに置き換えられました。クラウド サービスを使用すると、さらに簡単にご支援を行うことができます。
この講演では、Azure サービスを使用してアプリケーションを自動化し、継続的にデプロイする方法について詳しく説明します。まず、A/B テストや自動承認ゲートなど、開発者が制御する自動化された操作 (DevOps) について話し合います。次に、Azure の新しい DevOps プロジェクトを使用してクラウドに完全に移行し、ボタンを数回クリックするだけでフロントエンド Web アプリケーション、バックエンド Web サービスとデータベース、モバイル アプリケーションのデプロイを自動化する方法を示します。


## 機能

このプロジェクトでは、次の例を示します。

* [Azure Pipelines](https://azure.microsoft.com/ja-jp/services/devops/pipelines/?WT.mc_id=msignitethetour-github-dev20)
* [Azure Pipelines App for GitHub](https://github.com/marketplace/azure-pipelines)
* [Azure DevOps Deployment Gates](https://docs.microsoft.com/ja-jp/azure/devops/pipelines/release/approvals/gates?WT.mc_id=msignitethetour-github-dev20)
* [Azure App Service Deployment Slots](https://docs.microsoft.com/ja-jp/azure/app-service/web-sites-staged-publishing?WT.mc_id=msignitethetour-github-dev20)

## 追加リンク

* [Azure DevOps Documentation](https://docs.microsoft.com/ja-jp/azure/devops/index?WT.mc_id=MSIgniteTheTour-github-dev20)
* [DevOps Resource Center](https://docs.microsoft.com/ja-jp/azure/devops/learn/?WT.mc_id=MSIgniteTheTour-github-dev20)

# デモ ウォークスルー:
これは DevOps セッションのデモ スクリプトです。このセッションでは、

- Github から Azure パイプラインへの CI Yaml ベースのパイプラインの作成。
- ABテストで高度な開発のベストプラクティスを追加
- Azure モニタリングを品質ゲートとして使用して、ステージ間に自動承認ゲートを追加する
- Azure DevOps プロジェクトを使用して、任意の言語のプロジェクトを開始する高速トラック
- 追い風取引のための現実世界のビルドとリリースパイプラインを歩きます。


## セットアップ
This session's demos are done using the browser and one instance of VSCode. Open up an instance of your favorite browser and have the following tabs.
このセッションのデモは、ブラウザと VSCode の 1 つのインスタンスを使用して行われます。お気に入りのブラウザを開き、次のタブを保持してください。

<!-- TODO: update properly links-->
1. `Tab 1 - GitHub リポジトリ for tailwind front end` https://github.com/sasukeh/AbelTailWindFrontEnd
![](readmeImages/2018-11-09-07-48-15.png)
1. `Tab 2 - AzureのDevOpsダッシュボード ` https://ms.portal.azure.com/#@microsoft.onmicrosoft.com/dashboard/private/b490f4aa-5eaf-49d9-af61-3381ac839138
![](readmeImages/2018-11-19-21-01-00.png)
1. `Tab 3 - Tailwind Build All Up` https://dev.azure.com/azuredevopsdemo-a/AbelTailwindInventoryService/_apps/hub/ms.vss-ciworkflow.build-ci-hub?_a=edit-build-definition&id=27
![](readmeImages/2018-11-09-07-59-05.png) 
1. `Tab 4 - Tailwind Release All Up` https://dev.azure.com/azuredevopsdemo-a/AbelTailwindInventoryService/_releaseDefinition?definitionId=1&_a=definition-pipeline
![](readmeImages/2018-11-09-09-09-09.png)
1. `Tab 5 - Release Gate Docusign Example`
https://msvstsdemo-a.visualstudio.com/YoCoreDemo/_releaseProgress?releaseId=10&_a=release-pipeline-progress
![](readmeImages/2018-11-09-09-10-39.png)
1. `Tab 6 - Release Gate Dynatrace Unbreakable Pipeline Pass`
https://msvstsdemo-a.visualstudio.com/AbelUnbreakablePipelineDemo/_releaseProgress?releaseId=275&_a=release-pipeline-progress
![](readmeImages/2018-11-09-09-11-41.png)
1. `Tab 7 - Release Gate Dynatrace Unbreakable Pipeline Fail`
https://msvstsdemo-a.visualstudio.com/AbelUnbreakablePipelineDemo/_releaseProgress?releaseId=276&_a=release-pipeline-progress
![](readmeImages/2018-11-09-09-12-34.png)

別のブラウザを開きます。Chromeを使用して最初のセットを開いた場合は、Firefox または Edge を使用してください。このブラウザで 2 つのタブを開きます。

1. `Tab 1 - Tailwind Traders Staging` https://abeltailwindfrontend4staging.azurewebsites.net/
![](readmeImages/2018-11-09-09-14-45.png)
2. `Tab 2 - Tailwind Traders Production` https://abeltailwindfrontend4.azurewebsites.net/
![](readmeImages/2018-11-09-09-15-37.png)

このデモでは、VSCode を使用してコードを変更することもできます。

1.  `src/style.css`をVSCodeで開く

## クリーンアップ

1. ビルドパイプラインとリリースパイプラインの削除 https://dev.azure.com/azuredevopsdemos-a/AbelTailWind
    - [Damovisa.ignite-tour-lp1s2 - CD](https://dev.azure.com/azuredevopsdemo-a/AbelTailWind/_release?view=mine)
    - [Damovisa.ignite-tour-lp1s2](https://dev.azure.com/azuredevopsdemo-a/AbelTailWind/_build_)
1. 変更 [Testing In Production for ABTesting slot](https://ms.portal.azure.com/#@microsoft.onmicrosoft.com/resource/subscriptions/e97f6c4e-c830-479b-81ad-1aff1dd07470/resourceGroups/AbelIgnite2018WServers/providers/Microsoft.Web/sites/AbelTailWindFrontEnd4/testingInProduction) to 0%
1. 削除 [ABTesting slot](https://ms.portal.azure.com/#@microsoft.onmicrosoft.com/resource/subscriptions/e97f6c4e-c830-479b-81ad-1aff1dd07470/resourceGroups/AbelIgnite2018WServers/providers/Microsoft.Web/sites/AbelTailWindFrontEnd4/deploymentSlots)
1. `az-pipelines.yml` の削除
1. [Remove marketplace app access to the ignite-tour-lp1s2 repo in GitHub](https://github.com/settings/installations/380745)
1. `/src/Nav.js` に行き`heading`をリセットするand reset the heading
![](readmeImages/2018-11-28_15-56-20.png)

## セッションスクリプト 
### スライドデック
1. DevOps について皆さんとお話しできることをとても楽しみにしています。今、私はあなたが考えていることのいくつかを想像できます。
クールなDevOps!そして、他の何人かはおそらく, DevOps?かまいません。CI/CD パイプラインですよね?なぜ気にする必要があるの?と考えて居ることでしょう
 ![](readmeImages/2018-11-09-09-25-15.png)

 1. 私はあなたにすべての理由を与えることができ、私は私の声明をバックアップするためにチャートやグラフを引き出すことができます。しかし、DevOps の前後の違いを実際に擬人的に示すショートフィルムを見せたかったのです。
![](readmeImages/2018-11-09-09-32-26.png)

こちらの動画：https://www.youtube.com/watch?time_continue=128&v=RRy_73ivcms

![](readmeImages/2018-11-09-09-33-37.png)

1. このようにビジネスに対応するためにDevOps を行う必要があります。年に一度私たちのコードを展開しようとする、昔のやり方を持つサーバではなく、ピットクルーのように油を注ぐ機械にする必要があり、継続的に価値を提供しなければなりません。

1. 今、私はDevOpsについて多く言及しましたが、正確にはDevOpsとは何ですか。この部屋の10人にDevOpsとは何かを尋ねると、10種類の回答が得られます。そして、私は他の誰かの定義が間違っていると言っているわけではありません。しかし、私たちが持っているこの会話をフレーム化するために、私はあなたにDevOpsのマイクロソフトの定義をお伝えします。
![](readmeImages/2018-11-09-09-36-39.png)

1. マイクロソフトでは、DevOps は非常に特殊なものです。Devops は、エンド ユーザーに継続的に価値を提供できるようにする、人、プロセス、および製品の結合です。今、私は超慎重に言ったことに気づく。私はコードを絶え間なく提供しているとは言っていませんでした。それは私たちに与えるものので、ちょうど私たちのエンドユーザーに役に立たないコードのパイルと山。そして、気づき、私は継続的に機能を提供することさえ言っていませんでした。機能の後に機能を提供できる可能性がありますが、価値を提供していない場合は、時間を無駄にするだけです。
![](readmeImages/2018-11-09-09-38-08.png)

1. なぜこれが重要なのでしょうか?なぜDevOpsを気にする必要があります。今日のビジネスのスピードは非常に速いので、DevOps のベスト プラクティスを採用する必要があります。そうしないと、競合他社は DevOps のベスト プラクティスを採用するか、採用します。そして、彼らはそうする、彼らは私たちを革新し、彼らは私たちを時代遅れにします。そして、誰も時代遅れにされたいと思いません。
![](readmeImages/2018-11-09-09-40-39.png)
1. これはもはや単なる理論ではありません。私たちは今、これを明確に示す冷たいハードインペリック事実を持っています。DevOps のベスト プラクティスを採用すると、市場投入速度が速く、故障率が低くなります。変更のリードタイムがはるかに速く、平均復旧時間がはるかに速くなります。そして、このすべては何に変換されますか?収益の増加!
![](readmeImages/2018-11-09-09-42-09.png). 

1. DevOps を正常に実装するには、ソフトウェアを作成するときに 3 つの柱をすべて攻撃する必要があります。人、プロセス、製品に対応する必要があります。
![](readmeImages/2018-11-09-09-45-07.png)

1. 人々の部分にとって、それは最も難しい変化です。これは、組織で行われる必要がある文化的なシフトです。トップダウンの誰もが、継続的に価値を提供することに重点を置く場所。私は、まあ、私たちは常に誰からも物事を行う方法を聞きたくありません。誰もが継続的にvaueを提供することに焦点を当てる必要があります。
![](readmeImages/2018-11-09-09-52-52.png)

1. プロセスでは、十分な速さでインターテートし、それでも十分な品質のコードを提供できるプロセスが必要です。どういう意味なの?スプリントを計画できる必要があり、自分が行っている作業を追跡しながらコードをチェックインおよびチェックアウトできる必要があります。そして、私はコードをチェックインし、チェックアウトしているように?ビルドを開始する必要があります。自動テストを実行する必要があります。セキュリティ スキャンを行う必要があります。ビルドが良好な場合、自動化されたシステムは私のビットをピックアップし、私の開発、QA、UATにデプロイする必要があります。そして、なぜこれを自動化する必要があるのでしょうか?潜在的に、これは1日に何度も起こる可能性があります!そのため、プロセスの一貫性と繰り返し可能性を確認する必要があります。時計の仕事のように毎回。そして、コードが運用環境に到達すると、それはそこで終わりません。運用環境でコードを監視できる必要があります。私たちは、アプリが上下しているか、アプリがうまく動作しているか、ユーザーが実際にアプリで何をしているのかを知る必要があります。これらの質問に対する答えは、私がエンドユーザーにvaueを提供しているかどうかを私に知らせるからです。もしそうなら、次のスプリントでこれらのタイプの活動を倍増することができます。そうでない場合は、バックログとコースの正しい優先順位をすぐに変更できます。![](readmeImages/2018-11-09-09-54-28.png)

1. このすべてを有効にするのに役立つ適切な製品とツールが必要です。そのため、スプリント全体を通じて作業を追跡できるツールが必要です。私たちは、私たちのチェックインに私たちの仕事を腐食させることができるソース管理システムが必要です。すべてのチェックインに基づいて構築し、すべての単体テストを実行し、運用環境に至る展開を自動化できる自動ビルドおよびリリース システムが必要です。また、本番環境でアプリを監視するシステムが必要です。
![](readmeImages/2018-11-09-09-58-25.png)

1. 世の中には、こういうことをする道具がたくさんあります。Azure はオープン システムであり、最もよく知られているすべての DevOps ツールを引き続き使用できます。
![](readmeImages/2018-11-09-10-00-45.png)

1. ただし、それらのすべてを 1 つの製品に置き換えることができます。Azure DevOpsです。
![](readmeImages/2018-11-09-10-01-40.png)

1. Azure DevOps は、文字通り、任意のプラットフォームを対象とする任意の言語に対して、アイデアを取り入れ、そのアイデアをエンド ユーザーの手に渡すソフトウェアに変換する必要があるすべてです。Azure DevOps は、シームレスに連携する 5 つのセパレート製品のスイートです。Azure Boards と呼ばれる作業項目の追跡製品があり、すべての作業を管理するのに役立つビジュアル ツールを使用して、ソフトウェア プロジェクト内の任意の作業単位を追跡できます。Azure パイプラインがあり、任意のプラットフォームを対象とする任意の言語に対して CI/CD パイプラインを構築できます。独自の Git リポジトリまたは一元化されたバージョン管理システムをホストできる Azure リポジトリがあります。すべての手動テストを作成、計画、および実行するための Azure テスト計画があります。最後に、パッケージ管理システムをホストできる Azure Artifacts が登場します。

![](readmeImages/2018-11-09-10-03-00.png)

1. 本日のセッションでは、Azure Pipeline に集中し、コードをより速く、より安全にデプロイします。
![](readmeImages/2018-11-09-10-06-46.png)

### Demo
[Bring up main browser with all the tabs and bring up tab 1]

TailWind のコードはすべて github にあり、github から Azure パイプラインに CI/CD パイプラインを構築する必要があります。これは、Azure パイプライン市場の場所拡張で行うのは非常に簡単です。マーケットプレースにアクセスして、Azure パイプライン拡張機能を検索できます。

![](readmeImages/2018-11-09-10-50-00.png)

![](readmeImages/2018-11-09-10-51-07.png)

![](readmeImages/2018-11-09-10-52-12.png)

拡張機能を既にインストールしているので、この拡張機能を設定してみましょう

![](readmeImages/2018-11-09-10-52-57.png)

![](readmeImages/2018-11-09-10-53-32.png)

![](readmeImages/2018-11-09-10-53-55.png)

そして、テールウィンドフロントエンドレポのCIパイプラインを作成するように構成します。
    
![](readmeImages/2018-11-09-10-55-14.png)

これにより、Azure DevOps のログイン画面が表示されます。

![](readmeImages/2018-11-09-10-56-02.png)

![](readmeImages/2018-11-09-10-57-27.png)

CI パイプラインをすばやくセットアップするのに役立つウィザードを使用する場合

![](readmeImages/2018-11-09-12-10-36.png)

![](readmeImages/2018-11-09-14-16-22.png)

![](readmeImages/2018-11-09-14-16-38.png)

Azure Pipelines はリポジトリを分析し、リポジトリ内のテクノロジと言語に適したテンプレートを提供します。このリポジトリは node.js アプリなので、Node.js テンプレートを選択してみましょう

![](readmeImages/2018-11-09-14-18-15.png)

これにより、**azure-pipelines.yml** ファイルが作成されます。したがって、yaml ビルド パイプラインが作成されます。Azure パイプラインのビルド エンジンは、基本的にタスク ランナーです。次から次へとタスクを実行します。また、ビジュアル エディタまたは yaml ファイルを使用してタスクを記述することもできます。yaml ビルドまたは **パイプラインを Code**として使用すると、多くの利点があります。主に、ビルド パイプラインがソース管理に正しくチェックインされ、ビルド パイプラインがソース コードと一緒にバージョン管理されます。yaml ビルドに関する詳細情報が必要な場合は、ドキュメントのリンクに従ってください。
   
![](readmeImages/2018-11-09-14-23-27.png) 
   
![](readmeImages/2018-11-09-14-24-23.png)

このビルドを保存して実行してみましょう

![](readmeImages/2018-11-09-14-26-03.png)

![](readmeImages/2018-11-09-14-26-41.png) 

![](readmeImages/2018-11-09-14-27-39.png)

これにより、azure-pipeines.yml ファイルが git リポジトリに保存され、ビルドが起動します。ビルドでは何が起こるのでしょうか? 最初に git hub からすべてのソース コードをダウンロードし、次に yml ファイルに記述されているビルド ステップを実行します。私たちの場合はそうです

- ソースコードをダウンロードします
- Node.js をインストールします。
- npm のインストールとビルドを行います

今、これは問題ありませんが、私は少しビルドをカスタマイズしたいと私はビジュアルエディタがどのように見えるかをすべて示したいと思います。それでは、ビジュアルエディタに期待してみましょう

![](readmeImages/2018-11-09-14-38-59.png)

![](readmeImages/2018-11-09-14-40-24.png)

ここでは、個々のステップを見ることができ、今、私は私のビルドを構成しています

- npm をインストールする
- DB 接続文字列のセットアップ
- node.js アプリから staic Web アプリを作成しているため、アプリをビルドします。
- 展開の準備が整ったように、すべてを圧縮します
- ビルドアーティファクトとして Web サイトの zip を Azure パイプラインに公開する

Azure パイプラインのビルド システムは、何でも行うための 100% 構成可能です。任意のプラットフォームをターゲットに任意の言語!このビルドをカスタマイズする方法は、タスクを追加および削除することです。

![](readmeImages/2018-11-09-14-48-23.png)

![](readmeImages/2018-11-09-14-49-20.png)

箱から出すところには、左にドラッグして使用を開始できる、フンドタスクの上に少しあります。

箱から出さない何かをしたいのなら?

![](readmeImages/2018-11-09-14-52-17.png)

大したことではないが、私たちのパートナーが500以上のビルドとリリースタスクを作成した市場に行くだけで、ダウンロードして使用を開始できます。

そして、あなたは箱から出ておらず、市場ではない何かをしたい場合は?独自のカスタム タスクを作成できるため、問題はありません。カスタム タスクは、powershell または node.js 以外の何物でもない。つまり、コマンド ラインからできることは何でも簡単にこのビルドとリリース システムを取得できます。これは、このビルドとリリースシステムは何でも行うことができます!任意のプラットフォームをターゲットに任意の言語!

さて、私は起こりたいカスタマイズされたビルドを説明するビジュアルビルドを持っているので、YAMLビルドにこれを追加する最も簡単な方法は、

![](readmeImages/2018-11-09-14-55-49.png)

このビジュアル ビルドによって生成される yaml を表示する

先に進んでコピーしてから、これを azure-pipelines.yml ファイルに貼り付けます。

![](readmeImages/2018-11-09-14-56-59.png)

VSCode に戻り、最新の変更を git プルでプルダウンします。

![](readmeImages/2018-11-09-14-58-24.png)

そして今、yamlを貼り付け、azure-pipelines.ymlのすべてを置き換えてみましょう

![](readmeImages/2018-11-09-15-00-32.png)

そして今、そのyamlファイルをGitHubにプッシュしてみましょう。そして、コードがgithubにヒットすると、新しいビルドが始まります

![](readmeImages/2018-11-09-15-06-54.png)

![](readmeImages/2018-11-09-15-07-14.png)
   
このビルドは何をしていますか?azure-pipelines.yml ファイルを含む最新のソースを github からダウンロードしています。次にビルドを開始し、yml ファイルに記述されているビルド ステップを実行します。パイプラインをコードとして使用します!!!.そして、それは

- npm のインストールを行う
- db 接続の設定
- アプリのビルド
- 展開の準備ができているようにウェブサイトをジッパーアップ
- このビルドのビルド成果物として zip ファイルを Azure パイプラインにパブリッシュする

ああ、あなたが気づいた場合は、今、私はちょうど私のデータベースのエンドポイントをハードコーディングしています。より安全にしたい場合は、パイプラインにシークレットを保存し、yaml ファイル内のシークレットを使用することもできます。

シークレットを設定するには、ビルドを編集してみましょう

![](readmeImages/2018-11-09-15-11-11.png)

![](readmeImages/2018-11-09-15-13-28.png)

ここで変数を追加し、それらをロックして暗号化し、azure-pipelines.yml ファイルに戻ると、32 行目と 33 行目を追加して秘密のビルド変数を参照できます。

![](readmeImages/2018-11-09-15-15-56.png)

はい、ビルドが完了したように見えます

![](readmeImages/2018-11-09-15-17-08.png)

また、ビルド中に発生したすべてのテストを示す優れたビルド レポートが表示されます。

![](readmeImages/2018-11-09-15-17-42.png)

ドロップをクリックしてビルドアーティファクトを調べることさえできます。

![](readmeImages/2018-11-09-15-19-02.png)

あなたが見ることができる場所は、我々はウェブサイトのzipファイルを作成しました

![](readmeImages/2018-11-09-15-19-29.png)

このように、ビルド パイプラインを作成できます。しかし、我々はまだこのアプリをリリースするためにリリースパイプラインを作成する必要があります。これを行うには、[リリース] ボタンをクリックするだけです。

![](readmeImages/2018-11-09-15-20-41.png)

リリース パイプラインのビジュアル エディタが表示されます。Tailwind Traders の Web サイトは Azure アプリ サービスでホストされます。

![](readmeImages/2018-11-09-15-22-21.png)

これで、リリースの構成を完了する必要があります。リリースを構成するには、まずステージまたは環境を作成します。最初にデプロイする環境はステージング環境なので、名前を 「ステージング」に置き換えます。


![](readmeImages/2018-11-09-15-24-17.png)

ステージを定義した後、次に、そのステージにアプリをデプロイする手順を定義します。したがって、ステップリンクをクリックすると、このステージのタスクランナーに案内されます。

![](readmeImages/2018-11-09-15-25-22.png)

また、App Service デプロイメント テンプレートを既に選択しているため、構成が残っているわけではありません。Azure サブスクリプションを選択し、デプロイ先のアプリ サービスを選択するだけで済みます。この場合、Tailwind フロント エンド ステージング アプリ サービスにデプロイします。

![](readmeImages/2018-11-09-15-27-16.png)

ステージを定義し、アプリの展開に必要な手順を定義したので、各ステージの前後に手動承認者を選択できます。ステージング環境では、ポストデポイメント承認を作成してみましょう。これにより、新しいビルドが開始された場合、手動による介入なしでステージング環境に自動的にデプロイされます。

![](readmeImages/2018-11-09-15-29-23.png)

![](readmeImages/2018-11-09-15-33-43.png)

このデモの手動承認者として自分自身を追加します。手動ゲートを通過する前に、リストの全員が承認する必要があるユーザーのリストを追加できます。または、ユーザーのグループを作成し、グループ内の 1 人が承認した場合、ゲートを通過します。または、リストとグループの組み合わせを使用することもできます。そのため、必要な量にセキュリティを強化できます。

次に、運用環境に展開する別のステージを追加します。環境にカーソルを合わせると、クローンを選択して環境のクローンを作成します。

![](readmeImages/2018-11-09-15-35-50.png)

そして、私たちは新しいステージProdに名前を付けます

![](readmeImages/2018-11-09-15-46-22.png)

次に、リリース手順を少し調整して、運用環境に展開する必要があります。

prod 環境の手順をクリックします。

![](readmeImages/2018-11-09-15-48-12.png)

アプリ サービスを運用アプリ サービスに変更します。

![](readmeImages/2018-11-09-15-48-41.png)

保存とボイラをクリックしてください!Tailwind Traders のフロントエンドをステージング環境にリリースし、承認者を運用環境にリリースするリリース パイプラインを作成しました。

リリースをクリックして [リリースの作成] をクリックします。

![](readmeImages/2018-11-09-15-50-51.png)

次に、[作成] をクリックして最新のビルドを使用してリリースを作成します。

![](readmeImages/2018-11-09-15-51-44.png)

![](readmeImages/2018-11-09-15-52-21.png)

リリースがライブで行われるのを見ることができる場所。
 ![](readmeImages/2018-11-09-15-52-52.png)

何が起きてるの?リリースはビルドのドロップ場所に向かいます。ドロップの場所からデプロイメント ビットをピックアップし、ステージング ステージ用に構成した手順に基づいてステージング環境にそれらのビットをデプロイします。

![](readmeImages/2018-11-09-15-55-57.png)

ビルドと同様に、リリースは完全にカスタマイズ可能で、何でも行うことができます。これは単なるタスク ランナーなので、ビルド パイプラインと同様に、タスク ランナーを追加および削除してリリース手順をカスタマイズします。何百ものタスクが市場から来ています。また、このリリース システムで何でも実行できる独自のカスタム タスクを作成できます。

![](readmeImages/2018-11-09-15-57-01.png)

[OK] をクリックすると、ステージング環境でリリースが完了したように見え、展開後の承認を待っています。

![](readmeImages/2018-11-09-15-58-58.png)

![](readmeImages/2018-11-09-15-59-50.png)

承認する前に、ステージング環境を確認して、新しいコードが実際にデプロイされているかどうかを確認します。

- 2つのタブでフロントエンドを持つブラウザを起動し、タブ1を起動します

  ![](readmeImages/2018-11-09-16-00-54.png)

- [更新] をクリックします。
     
  ![](readmeImages/2018-11-09-16-02-23.png)

ボイラ!ステージング環境にデプロイされたコード!

Azure パイプラインに戻り、デプロイ後の承認をクリックできるようになりました。

![](readmeImages/2018-11-10-07-07-47.png)

![](readmeImages/2018-11-10-07-08-07.png)

![](readmeImages/2018-11-10-07-08-33.png)

そして今、コードはProd環境に流れ込む

![](readmeImages/2018-11-10-07-09-12.png)

何してるの?リリース管理は、この特定のビルドのドロップ場所に配置されます。ステージング用のビットをピックアップしたのとまったく同じドロップ場所。また、ステージングにデプロイしたのとまったく同じビットを運用環境にデプロイします。開始された新しいビルドはありません。迷子のコードが入り込む方法はありません。まったく同じビットです。

[OK] をクリックすると、ビットがデプロイされ、展開後の承認が待っています。

生産をチェックしよう

![](readmeImages/2018-11-10-07-11-24.png)

そしてリフレッシュ

![](readmeImages/2018-11-10-07-11-35.png)

バム! 新しいコードは、prod にすべての方法を展開しました。だから今、私はポスト展開の承認を承認します

![](readmeImages/2018-11-10-07-12-21.png)

![](readmeImages/2018-11-10-07-12-27.png)

![](readmeImages/2018-11-10-07-12-33.png)

そして今、私たちは最初のビルドとリリースパイプラインを構築し、githubからのチェックインは、ステージングを通じてビルドとリリースを開始します。

クールだろ?

でも 知ってる?私たちはさらに良いことができます。Azure パイプラインは、リリース システムで何でも実行できる完全にカスタマイズ可能であることを覚えておいてください。高度な DevOps のベスト プラクティスを含む。Blue Green のデプロイなど、最初に運用環境の正確なレプリカである環境にデプロイします。テストを行い、準備ができたら、BlueGreen 環境と生産を入れ替えます。だから今、生産にあったものは私のブルーグリーンスポットにあり、私のブルーグリーンスポットにあったものは、現在生産中です。このような操作は、Azure パイプラインを使用して簡単に実行できます。AB テストのようなものでも、新しいコードを展開し、新しいコードに 10% のようにトラフィックの一部だけをルーティングし、トラフィックの残りの部分を古いコードにルーティングします。これにより、テレメトリをゆっくりと慎重に収集し、価値を提供していることを確認できます。物事が良く見える場合は、トラフィックを 20、30 最終的には 100% にゆっくりと増やすことができます。

実際、Azure パイプラインと Azure App サービスの力を使用して、これは本当に簡単です。これがいいと思います。

[Go back to main browser,  `Tab 2 - Tailwind Front End App Service in Portal`]

テールウィンド トレーダーのフロントエンドをホストしているアプリ サービスの Azure ポータル ページを次に表示します。

![](readmeImages/2018-11-10-16-31-18.png)

ABテストを実装するには、**開発ツール**までスクロールし、生産における**テストを選択します**

![](readmeImages/2018-11-10-16-38-42.png)

ここでは、配置スロットを追加します。展開スロットは...Web アプリの仮想ディレクトリと考えてください。

![](readmeImages/2018-11-10-16-39-37.png)

スロットを作成し、どのスロットにルーティングするトラフィックの割合を指示します。

私はこの新しいスロットに名前を付けます **ABTesting**

![](readmeImages/2018-11-10-16-41-09.png)

そして、これは私のスロットを作成します。次に、スロットにルーティングするトラフィックの割合を追加するだけです。このデモでは、50%を選びます。

![](readmeImages/2018-11-10-16-42-35.png)

インフラストラクチャ側で行う必要があるのはそれだけです。パイプラインで AB テストを実装するには、簡単な変更を行う必要があります。

[Bring up browser tab with Azure Pipeline]

![](readmeImages/2018-11-12-08-09-39.png)

まず、Prod 環境のクローンを作成し、それを Prod B と呼びます。

![](readmeImages/2018-11-12-08-11-45.png)

![](readmeImages/2018-11-12-08-12-08.png)

次に、Prod ステージの名前を Prod A に変更します。

![](readmeImages/2018-11-12-08-12-48.png)

また、新しいコードを運用スロットに展開する代わりに、新しいコードを作成した ABTesting スロットに展開するため、展開手順を調整する必要があります。

![](readmeImages/2018-11-12-08-16-41.png)

そして、保存し、バム。それだけださて、これを実際に見るために、いくつかのコードを変更してみましょう。

アプリの背景を紫色に変えよう

![](readmeImages/2018-11-12-08-29-50.png)

保存して github にコミットする

![](readmeImages/2018-11-12-10-45-24.png)

これは私たちのビルドをキックオフします

![](readmeImages/2018-11-12-10-45-58.png)

そして、このビルドで何が起こっているのでしょうか?

![](readmeImages/2018-11-12-10-46-16.png)

ビルド エンジンは、azure-piplines.yml ファイルを含む github から最新の変更をダウンロードしています。次に、ビルド エンジンは yaml ファイルで定義されたすべてのステップの実行を開始します。 

- NPM インストール
- セットアップ DB 接続文字列とエンドポイント
- 静的ファイルにアプリを構築
- ビルドアーティフィカツは、すべての展開の準備ができてWebアプリのzipファイルであることを確認するために、すべてをジップアップ
- Azure パイプラインに戻って公開されたビルド アーティファクト。

そして、これが実行されている間、私はあなたにもう一つのものを見せたかった。今のところ、データベースのユーザーとパスワードは yml ファイルにプレーン テキストとして保存されているだけなので

![](readmeImages/2018-11-12-11-08-59.png)

ビルドを編集することで、Azure Pipleines にシークレットを簡単に保存して使用できます。

![](readmeImages/2018-11-12-11-09-59.png)

誰も見ることができないように暗号化されたパイプラインのシークレットを格納できる場所。そして、それらを使用するには、あなたのymlファイルで、我々はちょうどこのようにそれらを参照します

![](readmeImages/2018-11-12-11-11-57.png)

[OK] をクリックすると、ビルドが完了し、リリース パイプラインが開始されました。


![](readmeImages/2018-11-12-11-45-59.png)

それで何をしてるの?リリース管理では、ビルドのアーティフィカットをビルドからダウンロードしています。この場合、コンパイル済みアプリケーションの zip ファイルが作成され、この新しいコードがデプロイされます。紫色の背景を持つものがステージング環境に入ります。そして、ここでは、ステージングに展開されます。

![](readmeImages/2018-11-12-11-15-03.png)

これを承認する

![](readmeImages/2018-11-12-11-46-41.png)

そして今、ビットはProd Aスロットに流れ始めます

![](readmeImages/2018-11-12-11-47-13.png)

では、本当に幸せなのは何でしょうか?リリース管理は、この特定のビルドのドロップ場所とまったく同じドロップ場所に行き、ビルドアーティファクトをダウンロードします。ステージングに展開したのとまったく同じビルドのアーティフキャットですか?ABTesting スロットにまったく同じビットを展開します。余分なビルドはなく、余分なコンパイルも、余分なバンドルも行われなかった。これらはまったく同じビットになります。

さて、TestABスロットにデプロイしました

![](readmeImages/2018-11-12-11-48-48.png)

本番環境をリフレッシュしてみましょう。

![](readmeImages/2018-11-12-11-50-32.png)

背景が紫色でないのはなぜですか? トラフィックの 50% を古いコードにルーティングし、トラフィックの 50% を新しいコードにルーティングすることに注意してください。それでは、別のブラウザを開きましょう

[メインブラウザに戻り、新しいタブを開き、フロントエンドprod URLをコピーして貼り付けます]

そして。。。


![](readmeImages/2018-11-12-11-54-41.png)

出来上がり！トラフィックの 50% が古いコードを経由し、トラフィックの 50% が新しいコードを経由してルーティングされます。テレメトリを収集して、価値を提供しているかどうかを判断できるようになりました。もしそうなら、私たちはこれを承認し、コードを承認することができます

![](readmeImages/2018-11-12-11-55-39.png)

新しいコードに 100% フローします。


![](readmeImages/2018-11-12-12-17-53.png)

ご覧の通り、パイプラインを簡単に設定できるため、フローを 10% から 20% に増分し、100% までゆっくりと増やすことができます。また、価値を与えていない場合は、デプロイを停止してロールバックするパイプラインを設定することもできます。

![](readmeImages/2018-11-12-12-18-45.png)


かっこいいな私はちょうどあなたを示した

- CI/CD パイプラインの作成
- Azure パイプラインと Azure アプリ サービスを使用した AB テストなどの高度な DevOps のベスト プラクティスの実装

しかし、私たちはさらに良いことができます!Azure パイプラインを使用すると、継続的な監視に基づいて自動承認ゲートを作成できます。そこで今、AIを使って承認プロセスを1段階から次の段階に自動化することができます!!!

たとえば、アプリケーション インサイトを使用して監視するステージング環境を設定しました。

[`Tab 3 - Application Insight for TailWind Traders Staging Environment`]
![](readmeImages/2018-11-12-12-41-33.png)

そして、ここで、私はアラートを設定しました

![](readmeImages/2018-11-12-12-43-02.png)

キャッチされていないブラウザベースのJavascriptアラートを探しています。また、これらの数が多すぎる場合は、アプリケーション インサイトでアラートが作成されます。

![](readmeImages/2018-11-12-12-43-43.png)

だから今の考え方は、私がステージング環境にデプロイすることです。その後、テストを実行し、ユーザーはステージング環境でテストを開始できます。また、Application INSIGHT で検出されたアラートやブラウザベースのエラーが多すぎる場合は、デプロイが自動的に停止し、運用環境に展開しません。すべてが順調に見える場合は、ユーザーの承認なしで自動的に運用環境に流れ込みます。

これを設定するには、ステージング環境のアプリケーションインサイトでアラートを設定し、自動ゲートを使用するようにリリース パイプラインを微調整する必要があります。

![](readmeImages/2018-11-12-13-12-55.png)
 
まず、展開後の手順から手動承認者を削除します。


 ![](readmeImages/2018-11-12-13-38-22.png)

次に、クエリ Azure モニター アラートの自動ゲートを追加します。

![](readmeImages/2018-11-12-13-40-46.png)

今、私はちょうど正しいAzureサブスクリプション、リソースグループとリソースの名前とアラート名を選択する必要があります

![](readmeImages/2018-11-12-13-40-56.png)

私の引っ張り周波数とゲートタイムアウトを設定し、これを保存し、それが私たちが行う必要があるすべてです。Appication Insight を使用した継続的な監視に基づいて、自動ゲートを設定しました。

リリースをキューに入れると

![](readmeImages/2018-11-12-13-43-01.png)

![](readmeImages/2018-11-12-13-43-21.png)

コードをステージング環境にデプロイします。展開するコードには、インデックス ページがヒットしない場合にブラウザ エラーが発生します。

![](readmeImages/2018-11-12-13-44-22.png)

そして、今

![](readmeImages/2018-11-12-13-44-33.png)

コードがデプロイされた後、ステージング環境を数回更新してみましょう

[Refresh staging 5 times]

そして、これはブラウザからアプリケーションインサイトエラーの束を生成する必要があります

[`Tab 3 - Application Insight for TailWind Traders Staging Environment`]

![](readmeImages/2018-11-12-13-46-57.png)

![](readmeImages/2018-11-12-13-47-04.png)

そして、ここでは、アプリケーションインサイトがブラウザエラーの束をキャッチしていることがわかります

つまり、ゲートがヒットすると、App Insight からのアラートが検出され、ゲートが失敗するので、壊れたコードが自動的に prod 環境にプッシュされないようにします!!!

そして、BAM!ゲートでアプリケーション インサイトアラートが検出されました。失敗し、ステージングでリリースが発生しました。

![](readmeImages/2018-11-12-13-49-46.png)

スーパークールなもの!!!

今まで何を見せた?

- あらゆるプラットフォームをターゲットにしたあらゆる言語に対して、CI/CDパイプラインを簡単に作成できます。
- AB テストなどの高度な DevOps のベスト プラクティスを含め、パイプラインでほとんど何でも簡単に実装できます。
- 継続的な監視を使用して自動承認ゲートを有効にすることもできるため、より迅速かつ安全に展開できるようになりました!!!

そして、このすべては簡単に行うことができます。 でも、お前に告白しよう私はDevOpsの実践者かもしれませんが、私は手でCI/CDパイプラインを構築する大ファンではありません。つまり、私は良いパイプラインの重要性を認識していますが、私はコードを書くのが大好きです!それが私を幸せにする理由です。そして、Azureの力で、私は数回のクリックで超簡単に始めることができます。「始める」とはどういう意味ですか?

Azure DevOps プロジェクトのパワーを使用して、数回クリックするだけで、開始に必要なすべてを作成できます。Azure パイプラインのチーム プロジェクト。私のリポジトリで選択した言語のサンプルコード。選択したテクノロジに適した CI/CD パイプラインと、Azure でプロビジョニングされたインフラストラクチャ。そして、私はちょうど数回のクリックでこのすべてを取得します。私が何を意味するか見せてあがろう。

[`Tab 4 - Azure Portal` ]
![](readmeImages/2018-11-09-07-50-20.png)

Azure Portal から、Azure DevOps プロジェクトを作成してみましょう。


![](readmeImages/2018-11-12-14-36-35.png)

今、最初に尋ねるのは、どの言語を使用するかです。あなたはもちろん、ノード、php、Java、Python、Rubyは来てより多くの言語で行く.NETを選ぶことができます!

![](readmeImages/2018-11-12-14-37-25.png)

このデモでは、ノードを選択し、次をクリックします。

次に、どのフレームワークを使用するかを尋ねています。このデモでは、単純な Node.js アプリを構築してみましょう。

![](readmeImages/2018-11-12-14-38-06.png)

次に、アプリをホストするインフラストラクチャを確認します。このデモでは、node.js アプリを kubernetes クラスターでホストしてみましょう。

![](readmeImages/2018-11-12-14-38-53.png)

次に、Azure DevOps のインスタンスを使用してすべてを調整します。ここから新しい新しいものを作成することも、既に存在する新しいものを使用することもできます。このデモでは、私は私のデモアカウントを選択し、私はプロジェクトIgniteTourに名前を付け、私のKubernetesクラスタIgniteTourClusterに名前を付け、完了をクリックして....

![](readmeImages/2018-11-12-14-42-10.png)

バム、それは文字通りあなたがする必要があるすべてです。さて、ちょうどキックバックし、Azureがあなたのためにすべてを構築してみましょう。Azure パイプラインのチーム プロジェクト。あなたが選んだランゲージのサンプルコードは、私たちの場合、ノードjsサンプルアプリ、gitリポジトリに座って。選択したテクノロジに適した CI/CD パイプラインで、kubernetes クラスターでホストされているドッカー コンテナーで実行されているノード js アプリ。また、Azure でプロビジョニングされたインフラストラクチャ。そのため、Azure でデプロイされた kubernetes クラスターです。そして、これがすべて完了したら、次のようなポータルブレードを取得します。

[`Tab 5 - Ignite 1 DevOps Project Dashboard` ]
![](readmeImages/2018-11-12-15-07-18.png)

左側に CI/CD パイプラインが表示されます。右側には、Azure でプロビジョニングされたすべてのインフラストラクチャが、Kubernetes クラスター、アプリケーション isight のインスタンス、Kubernetes クラスターで実行されている Web アプリを排除しています。

これらのリンクはすべて、リソース自体への深いリンクです。例えば

![](readmeImages/2018-11-12-15-07-43.png)

コードへのリンクをクリックすると、ノード js アプリを保持している git リポジトリに表示されます。

![](readmeImages/2018-11-12-15-18-12.png)

これは DevOps のベスト プラクティスを使用するノード js アプリにすぎないため、インフラストラクチャの Arm テンプレートをコードとして使用し、Helm グラフを使用して kubernetes アプリをパッケージ化しています。

ビルド パイプラインの場合

![](readmeImages/2018-11-12-15-19-19.png)

選択したテクノロジに適したビルド パイプラインを作成します。この場合、node.js サンプル アプリの docker イメージを作成し、そのイメージを Azure コンテナー レジストリのインスタンスにプッシュし、アプリを helm パッケージとしてパッケージ化するビルド パイプラインを取得します。

![](readmeImages/2018-11-12-15-20-20.png)

次に、リリース パイプラインの場合

![](readmeImages/2018-11-12-15-20-46.png)

![](readmeImages/2018-11-12-15-21-12.png)

選択したテクノロジに適したリリース パイプラインを作成します。

![](readmeImages/2018-11-12-15-21-43.png)

AZURE Kubernetes サービスの kubernetes クラスターを含む ARM テンプレートを使用して Azure インフラストラクチャを作成するパイプラインを作成します。そして、Helm を使用してアプリをデプロイします。

アプリをデプロイした後、ポータル ブレードからアプリ エンドポイントをクリックしても、アプリは使用できません。

![](readmeImages/2018-11-12-15-22-55.png)

Azure Kubernetes サービスにデプロイされたサンプル アプリを起動する


![](readmeImages/2018-11-12-15-23-37.png)

もう一度あなたはクリックのカップルでこのすべてを取得します!

だから百万ドルの質問。サンペル アプリの代わりに、実際のコードをこのパイプラインに取り込むにはどうすればよいでしょうか。

十分にシンプル

ギットレポに行く

![](readmeImages/2018-11-12-15-37-15.png)

これは単なる古いギットレポです。私たちのハードドライブにこれをクローンし、アプリケーションフォルダを削除し、ローカルリポジトリにアプリケーションをコピーするのに十分簡単です。これらの変更をコミットして Azure リポジトリにプッシュし、実際のコードを使用して CI/CD パイプラインを開始し、運用環境にすべてプッシュします。

ビルド パイプラインを編集して、これを行う別の方法もあります。

![](readmeImages/2018-11-12-15-39-18.png)

そして今、ソースを取得したら、Azure リポジトリからソースを取得する代わりに、実際のコードを保持している github リポジトリに切り替えて、[保存してキューにする] をクリックします。

![](readmeImages/2018-11-12-15-40-24.png)

![](readmeImages/2018-11-12-15-40-48.png)

これにより、実際のコードを github からビルドし、リリース パイプラインを通じて kubernetes クラスターに送信する必要があります。

そしてポータルに戻る

 [`Tab 6 - Ignite 2 DevOps Project Dashboard` ]

![](readmeImages/2018-11-12-15-42-59.png)

コードが github からプルされ、ビルドされ、デプロイされていることがわかります。

![](readmeImages/2018-11-12-15-43-33.png)

Bam！！！！そして、このすべては、クリックのカップルで。

皆に何を見せた?

- あらゆるプラットフォームをターゲットにしたあらゆる言語に対して、CI/CDパイプラインを簡単に構築できます。
- Azure パイプラインと Azure を使用して高度な DevOps 技術を簡単に実行できます。
- ゲートが通過する必要があるかどうかを判断するために継続的な監視を利用する自動展開ゲートを含めることさえできます。
- また、Azure DevOps プロジェクトを使用して数回クリックするだけで、CI/CD パイプラインを Azure にすばやくフォールディングできます。

今、私が示したこれらのデモのすべては、まだ比較的簡単です。このすべてが実際のアプリケーションでどのように動作するのでしょうか?テールウィンドトレーダーと同じように?

Tailwind Traders アプリケーションは、2 つのマイクロサービスを備えた node.js Web フロントエンドで構成されています。インベントリ サービスは、Azure App Service でホストされるドッカー コンテナーで実行される .net コア マイクロ サービスです。 製品サービスは、kubernetes クラスターでホストされているドッカー コンテナーで実行されるノード js マイクロ サービスです。Web フロントエンドは、Azure アプリ サービスでホストされる Node.js アプリです。最後に、iOS モバイル アプリのフロントエンドもあります。Azure パイプラインを使用して、この現実世界のシナリオを構築およびリリースできますか。

アブソルテイ!これがいいと思います


[`Tab 7 - Tailwind Build All Up` ]
https://dev.azure.com/azuredevopsdemo-a/AbelTailwindInventoryService/_apps/hub/ms.vss-ciworkflow.build-ci-hub?_a=edit-build-definition&id=27
![](readmeImages/2018-11-09-07-59-05.png) 

アプリケーションの 4 つの部分すべてを並列にビルドする 1 つのビルドを次に指定します。私たちは、
ホストされた Windows エージェントは、.net コア インベントリ サービスを構築し、ドッカー イメージを作成します。

![](readmeImages/2018-11-12-15-50-31.png)

次に、ubuntu エージェントを使用してノード js 製品サービス コンテナーを構築し、それからヘルム パッケージを作成します。

![](readmeImages/2018-11-12-15-51-35.png)

次に、別の ubuntu エージェントを使用してノード js Tailwind フロントエンド Web アプリケーションを構築します。

![](readmeImages/2018-11-12-15-52-12.png)

最後に、ホストされた mac エージェントの 1 つを使用して iOS アプリケーションを作成します。

1ビルド、4パラレルエージェントは、一度に私たちのアプリを構築します。私たちは、すべての3つのプラットフォームのためのエージェントを与える唯一のクラウドベンダーです。ウィンドウズ、リナックス、マック!!!!

リリース パイプラインでも同じことができます。

[`Tab 8 - Tailwind Release All Up` ]
![](readmeImages/2018-11-12-16-11-47.png)

我々は4つのパラレルトラックを持つ1つのリリースを持っているところ。インベントリ サービスをコンテナーとしてアプリ サービスにデプロイする 1 つのトラック

製品サービスを受け取り、Kubernetes クラスタに舵輪アプリとしてデプロイする 1 つのトラック

Web フロント エンドを App Service の静的サイトとしてデプロイする 1 つのトラック、最後に ios アプリを取り込んで App Store にデプロイするトラックの 1 つです。

現実の世界?もちろん。Azure パイプラインを使用すると、アプリの複雑性にかかわらず、任意のプラットフォームをターゲットに任意のアプリをデプロイできます。 リリース ゲートに関しては、リリース ゲートを使用する実際のケースをいくつかご覧ください。



[`Tab 9 - Release Gate Docusign Example`]

![](readmeImages/2018-11-09-09-10-39.png)

私は最近、物理的なドキュメントが署名され、彼らのドキュサインサーバーにアップロードせずに本番環境に展開できないルールを持っていた病院にいました。これは今ではボトルネックになり、運用環境への展開が行われる前に、物理的なユーザーがドキュメントが署名されたことを確認する必要がありました。 しかし、私はDocusignにrest apiがあることを知っていたので、ドキュメントが署名されているかどうかを確認するカスタムゲートを作成するのは非常に簡単でした。

![](readmeImages/2018-11-12-16-17-21.png)

だから今、コードがQAにデプロイされた後、テストが行われ、人間はそれをOKし、今、ゲートが始まりました。ゲートを設定すると、ポーリング頻度とタイムアウトを設定できます。この場合、ドキュメントが署名されているかどうかを確認するために 5 分ごとにプルしました。初めて、署名されませんでした。二度目は、まだ署名されていませんでした。15ミヌイテス後?Docuemnt が署名され、新しいデプロイが運用環境に自動的に展開されました。

これらのリリースゲートを使用する別の例は、リリースが良いかどうかを確認するために Dynatrace モニタリングを使用した場所です。

[`Tab 10 - Release Gate Dynatrace Unbreakable Pipeline Pass`]

![](readmeImages/2018-11-09-09-11-41.png)

![](readmeImages/2018-11-12-16-19-51.png)

この例では、コードをステージングに展開し、ロード テストを実行し、ゲートが開始され、dynatrace を使用して展開が良いか悪いかを判断します。この場合、すべての応答時間が良好に見え、ゲートが通過し、コードが運用環境に流れ込みます。

[`Tab 11 - Release Gate Dynatrace Unbreakable Pipeline Fail`]

![](readmeImages/2018-11-09-09-12-34.png)

![](readmeImages/2018-11-12-16-20-59.png)

ここで、コードがステージングにデプロイされ、ロード テストが実行された後、dynatrace はリリースが悪いと言う十分なアノモリを検出し、ゲートを失敗させ、不正なコードが運用環境に入らなかったことを検出しました。

ここでは、自動承認ゲートを使用する方法を確認できます。だから、あなたがそこに開発するすべては、これを行いましょう!!!dev.azure.comに移動し、CI/CD パイプラインの構築を開始し、すべての方がより速く、より安全にデプロイできるようにしましょう。
